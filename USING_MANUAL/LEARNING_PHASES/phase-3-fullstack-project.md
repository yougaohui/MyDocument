# ğŸŒ Phase 3: å…¨æ ˆé¡¹ç›®å®æˆ˜ (3-4å‘¨)

## ğŸ¯ é˜¶æ®µç›®æ ‡

**æ ¸å¿ƒç›®æ ‡ï¼š** ä»é›¶å¼€å§‹æ„å»ºå®Œæ•´çš„å…¨æ ˆå¥èº«ç¤¾äº¤å¹³å°

**å…·ä½“ç›®æ ‡ï¼š**
- âœ… è®¾è®¡å’Œå®ç°å®Œæ•´çš„å…¨æ ˆåº”ç”¨æ¶æ„
- âœ… å®ç°ç”¨æˆ·è®¤è¯ã€ç¤¾äº¤åŠŸèƒ½ã€å¥èº«è¿½è¸ªç­‰æ ¸å¿ƒåŠŸèƒ½
- âœ… æŒæ¡ç°ä»£å…¨æ ˆå¼€å‘æœ€ä½³å®è·µ
- âœ… å®Œæˆåº”ç”¨éƒ¨ç½²å’Œè¿ç»´

## ğŸ“‹ é¡¹ç›®æ¦‚è¿°

### é¡¹ç›®åç§°
**FitPro Social - æ™ºèƒ½å¥èº«ç¤¾äº¤å¹³å°**

### é¡¹ç›®æè¿°
ä¸€ä¸ªå®Œæ•´çš„å¥èº«ç¤¾äº¤å¹³å°ï¼Œæ”¯æŒç”¨æˆ·è®°å½•å¥èº«æ•°æ®ã€åˆ†äº«å¥èº«è®¡åˆ’ã€ä¸æœ‹å‹äº’åŠ¨ã€è·å–ä¸ªæ€§åŒ–æ¨èã€‚

### åŠŸèƒ½ç‰¹æ€§
- ç”¨æˆ·æ³¨å†Œå’Œç¤¾äº¤ç½‘ç»œ
- å¥èº«è®¡åˆ’å’Œè®°å½•
- æ•°æ®åˆ†æå’Œå¯è§†åŒ–
- ç¤¾åŒºäº’åŠ¨åŠŸèƒ½
- ä¸ªæ€§åŒ– AI æ¨è

### æŠ€æœ¯æ¶æ„
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Frontend (Next.js)                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  ç”¨æˆ·æ¨¡å—   â”‚ â”‚  å¥èº«æ¨¡å—   â”‚ â”‚  ç¤¾åŒºæ¨¡å—   â”‚ â”‚  åˆ†ææ¨¡å—  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Backend API (NestJS)                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Auth æ¨¡å—  â”‚ â”‚  User æ¨¡å—  â”‚ â”‚  Workout æ¨¡å—â”‚ â”‚  Social   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Database Layer                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ PostgreSQL  â”‚ â”‚    Redis    â”‚ â”‚   S3/OSS    â”‚ â”‚   AI SDK   â”‚ â”‚
â”‚  â”‚  ç”¨æˆ·/æ•°æ®  â”‚ â”‚   ç¼“å­˜      â”‚ â”‚  æ–‡ä»¶å­˜å‚¨   â”‚ â”‚  æ™ºèƒ½æ¨è  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“… å‘¨è®¡åˆ’

### ç¬¬6-7å‘¨ï¼šé¡¹ç›®è®¾è®¡å’Œæ¶æ„æ­å»º

#### ä»»åŠ¡ 3.1: ç³»ç»Ÿæ¶æ„è®¾è®¡ (3å¤©)

**ç›®æ ‡ï¼š** å®Œæˆå®Œæ•´çš„ç³»ç»Ÿæ¶æ„è®¾è®¡å’ŒæŠ€æœ¯é€‰å‹

**å…·ä½“æ­¥éª¤ï¼š**

1. **éœ€æ±‚åˆ†æå’ŒåŠŸèƒ½è®¾è®¡**
   - ç”¨æˆ·æ•…äº‹å’Œç”¨ä¾‹å›¾
   - åŠŸèƒ½æ¨¡å—åˆ’åˆ†
   - éåŠŸèƒ½æ€§éœ€æ±‚ï¼ˆæ€§èƒ½ã€å®‰å…¨ã€å¯æ‰©å±•æ€§ï¼‰

2. **æŠ€æœ¯æ¶æ„è®¾è®¡**
   - å‰ç«¯æ¶æ„ï¼šNext.js 14 + TypeScript
   - åç«¯æ¶æ„ï¼šNestJS + GraphQL/REST
   - æ•°æ®åº“æ¶æ„ï¼šPostgreSQL + Prisma
   - ç¼“å­˜æ¶æ„ï¼šRedis + Docker
   - éƒ¨ç½²æ¶æ„ï¼šVercel + Railway/é˜¿é‡Œäº‘

3. **å¤šæ™ºèƒ½ä½“ä»»åŠ¡åˆ†é…**
   ```yaml
   # architecture-design.yaml
   name: "fitpro-social-architecture"
   description: "å¥èº«ç¤¾äº¤å¹³å°æ¶æ„è®¾è®¡"
   agents:
     - name: "system-architect"
       role: "ç³»ç»Ÿæ¶æ„å¸ˆ"
       tasks:
         - "æ•´ä½“æ¶æ„è®¾è®¡"
         - "æŠ€æœ¯é€‰å‹å’Œæƒè¡¡åˆ†æ"
         - "éåŠŸèƒ½æ€§éœ€æ±‚å®šä¹‰"
     - name: "frontend-architect"
       role: "å‰ç«¯æ¶æ„å¸ˆ"
       tasks:
         - "å‰ç«¯æ¶æ„è®¾è®¡"
         - "ç»„ä»¶åº“å’ŒçŠ¶æ€ç®¡ç†é€‰å‹"
         - "æ€§èƒ½ä¼˜åŒ–ç­–ç•¥"
     - name: "backend-architect"
       role: "åç«¯æ¶æ„å¸ˆ"
       tasks:
         - "åç«¯æœåŠ¡æ¶æ„è®¾è®¡"
         - "æ•°æ®åº“æ¶æ„è®¾è®¡"
         - "API è®¾è®¡å’Œè§„èŒƒ"
     - name: "devops-architect"
       role: "DevOps æ¶æ„å¸ˆ"
       tasks:
         - "CI/CD æµç¨‹è®¾è®¡"
           - "äº‘æœåŠ¡é€‰å‹"
           - "ç›‘æ§å’Œæ—¥å¿—æ–¹æ¡ˆ"
   ```

**äº¤ä»˜ç‰©ï¼š**
- ç³»ç»Ÿæ¶æ„æ–‡æ¡£ï¼ˆåŒ…å«æ¶æ„å›¾ï¼‰
- æŠ€æœ¯é€‰å‹æŠ¥å‘Š
- éåŠŸèƒ½æ€§éœ€æ±‚è§„æ ¼
- é¡¹ç›®è·¯çº¿å›¾

#### ä»»åŠ¡ 3.2: é¡¹ç›®åˆå§‹åŒ–å’ŒåŸºç¡€é…ç½® (2å¤©)

**ç›®æ ‡ï¼š** å®Œæˆé¡¹ç›®åŸºç¡€ç»“æ„æ­å»ºå’Œå¼€å‘ç¯å¢ƒé…ç½®

**å…·ä½“æ­¥éª¤ï¼š**

1. **åˆ›å»º Monorepo ç»“æ„**
   ```bash
   # åˆ›å»ºé¡¹ç›®æ ¹ç›®å½•
   mkdir fitpro-social
   cd fitpro-social
   
   # åˆå§‹åŒ– Git
   git init
   git remote add origin https://github.com/ygh/fitpro-social.git
   
   # åˆ›å»ºå­é¡¹ç›®
   mkdir apps
   cd apps
   
   # åˆ›å»ºå‰ç«¯é¡¹ç›®
   npx create-next-app@latest frontend --typescript --tailwind --app
   cd frontend
   
   # åˆ›å»ºåç«¯é¡¹ç›®
   cd ..
   npx @nestjs/cli new backend --package-manager npm
   cd backend
   
   # åˆå§‹åŒ–pnpmå·¥ä½œç©ºé—´
   cd ..
   pnpm init-workspace
   ```

2. **åŸºç¡€é…ç½®**
   ```typescript
   // pnpm-workspace.yaml
   packages:
     - 'apps/*'
     
   // tsconfig.json (root)
   {
     "compilerOptions": {
       "target": "ES2020",
       "module": "ESNext",
       "moduleResolution": "node",
       "esModuleInterop": true,
       "strict": true,
       "skipLibCheck": true,
       "paths": {
         "@fitpro/*": ["apps/*/src/*"]
       }
     }
   }
   ```

3. **Oh-My-OpenCode é…ç½®**
   ```yaml
   # .oh-my-opencode/config.yaml
   name: "fitpro-social"
   version: "1.0.0"
   
   agents:
     - id: "frontend-dev"
       model: "gpt-4"
       role: "å‰ç«¯å¼€å‘"
       workingDir: "apps/frontend"
     - id: "backend-dev"
       model: "claude-3-5-sonnet"
       role: "åç«¯å¼€å‘"
       workingDir: "apps/backend"
     - id: "mobile-dev"
       model: "claude-3-5-sonnet"
       role: "ç§»åŠ¨ç«¯å¼€å‘"
       workingDir: "apps/mobile"
     - id: "devops"
       model: "gpt-4"
       role: "DevOps"
   
   workflows:
     default:
       - frontend-dev
       - backend-dev
     mobile-feature:
       - backend-dev
       - mobile-dev
   ```

**äº¤ä»˜ç‰©ï¼š**
- å¯è¿è¡Œçš„ monorepo é¡¹ç›®ç»“æ„
- åŸºç¡€é…ç½®æ–‡ä»¶ï¼ˆTypeScriptã€ESLintã€Prettierï¼‰
- å¼€å‘ç¯å¢ƒæ–‡æ¡£
- Oh-My-OpenCode é¡¹ç›®é…ç½®

#### ä»»åŠ¡ 3.3: æ•°æ®åº“è®¾è®¡å’Œåˆå§‹åŒ– (2å¤©)

**ç›®æ ‡ï¼š** å®Œæˆæ•°æ®åº“è®¾è®¡å’Œåˆå§‹åŒ–

**å…·ä½“æ­¥éª¤ï¼š**

1. **æ•°æ®åº“å»ºæ¨¡**
   ```prisma
   // schema.prisma
   generator client {
     provider = "prisma-client-js"
   }
   
   datasource db {
     provider = "postgresql"
     url      = env("DATABASE_URL")
   }
   
   model User {
     id            String    @id @default(cuid())
     email         String    @unique
     username      String    @unique
     passwordHash  String
     avatar        String?
     bio           String?
     createdAt     DateTime  @default(now())
     updatedAt     DateTime  @updatedAt
     
     workouts      Workout[]
     posts         Post[]
     comments      Comment[]
     likes         Like[]
     followers     Follow[]  @relation("following")
     following     Follow[]  @relation("follower")
     achievements  UserAchievement[]
   }
   
   model Workout {
     id          String    @id @default(cuid())
     userId      String
     user        User      @relation(fields: [userId], references: [id])
     type        WorkoutType
     name        String
     duration    Int       // åˆ†é’Ÿ
     calories    Int
     distance    Float?    // å…¬é‡Œ
     startTime   DateTime
     endTime     DateTime
     exercises   Exercise[]
     createdAt   DateTime  @default(now())
   }
   
   model Exercise {
     id          String    @id @default(cuid())
     workoutId   String
     workout     Workout   @relation(fields: [workoutId], references: [id])
     name        String
     sets        Int
     reps        Int?
     weight      Float?
     duration    Int?      // ç§’
   }
   
   model Post {
     id          String    @id @default(cuid())
     userId      String
     user        User      @relation(fields: [userId], references: [id])
     content     String
     mediaUrls   String[]
     workoutId   String?
     createdAt   DateTime  @default(now())
     updatedAt   DateTime  @updatedAt
     
     comments    Comment[]
     likes       Like[]
   }
   
   model Follow {
     id          String    @id @default(cuid())
     followerId  String
     followingId String
     follower    User      @relation("follower", fields: [followerId], references: [id])
     following   User      @relation("following", fields: [followingId], references: [id])
     createdAt   DateTime  @default(now())
     
     @@unique([followerId, followingId])
   }
   
   model Achievement {
     id          String    @id @default(cuid())
     name        String    @unique
     description String
     icon        String
     requirement Int       // è¾¾æˆæ¡ä»¶
     type        AchievementType
     
     users       UserAchievement[]
   }
   
   model UserAchievement {
     id            String    @id @default(cuid())
     userId        String
     user          User      @relation(fields: [userId], references: [id])
     achievementId String
     achievement   Achievement @relation(fields: [achievementId], references: [id])
     progress      Int       @default(0)
     completedAt   DateTime?
     createdAt     DateTime  @default(now())
     
     @@unique([userId, achievementId])
   }
   ```

2. **æ•°æ®åº“è¿ç§»**
   ```bash
   # ç”Ÿæˆè¿ç§»
   cd apps/backend
   npx prisma migrate dev --name init
   
   # ç”Ÿæˆ Prisma Client
   npx prisma generate
   
   # éªŒè¯æ•°æ®åº“è¿æ¥
   npx prisma studio
   ```

**äº¤ä»˜ç‰©ï¼š**
- å®Œæ•´çš„ Prisma Schema
- æ•°æ®åº“è¿ç§»æ–‡ä»¶
- ç§å­æ•°æ®è„šæœ¬
- æ•°æ®åº“æ–‡æ¡£

### ç¬¬8-9å‘¨ï¼šæ ¸å¿ƒåŠŸèƒ½å¼€å‘

#### ä»»åŠ¡ 3.4: ç”¨æˆ·è®¤è¯ç³»ç»Ÿ (3å¤©)

**ç›®æ ‡ï¼š** å®ç°å®Œæ•´çš„ç”¨æˆ·è®¤è¯å’Œæˆæƒç³»ç»Ÿ

**å…·ä½“æ­¥éª¤ï¼š**

1. **åç«¯è®¤è¯æ¨¡å—**
   ```typescript
   // apps/backend/src/auth/auth.module.ts
   import { Module } from '@nestjs/common';
   import { JwtModule } from '@nestjs/jwt';
   import { PassportModule } from '@nestjs/passport';
   import { AuthService } from './auth.service';
   import { AuthController } from './auth.controller';
   import { JwtStrategy } from './strategies/jwt.strategy';
   import { UserModule } from '../user/user.module';
   
   @Module({
     imports: [
       UserModule,
       PassportModule.register({ defaultStrategy: 'jwt' }),
       JwtModule.register({
         secret: process.env.JWT_SECRET,
         signOptions: { expiresIn: '7d' },
       }),
     ],
     controllers: [AuthController],
     providers: [AuthService, JwtStrategy],
     exports: [AuthService],
   })
   export class AuthModule {}
   
   // apps/backend/src/auth/auth.service.ts
   import { Injectable, UnauthorizedException } from '@nestjs/common';
   import { JwtService } from '@nestjs/jwt';
   import * as bcrypt from 'bcrypt';
   import { UserService } from '../user/user.service';
   
   @Injectable()
   export class AuthService {
     constructor(
       private userService: UserService,
       private jwtService: JwtService,
     ) {}
   
     async register(registerDto: RegisterDto) {
       const existingUser = await this.userService.findByEmail(registerDto.email);
       if (existingUser) {
         throw new UnauthorizedException('é‚®ç®±å·²è¢«æ³¨å†Œ');
       }
       
       const hashedPassword = await bcrypt.hash(registerDto.password, 10);
       const user = await this.userService.create({
         ...registerDto,
         passwordHash: hashedPassword,
       });
   
       const token = this.generateToken(user);
       return { user: this.sanitizeUser(user), token };
     }
   
     async login(loginDto: LoginDto) {
       const user = await this.userService.findByEmail(loginDto.email);
       if (!user) {
         throw new UnauthorizedException('é‚®ç®±æˆ–å¯†ç é”™è¯¯');
       }
       
       const isPasswordValid = await bcrypt.compare(loginDto.password, user.passwordHash);
       if (!isPasswordValid) {
         throw new UnauthorizedException('é‚®ç®±æˆ–å¯†ç é”™è¯¯');
       }
   
       const token = this.generateToken(user);
       return { user: this.sanitizeUser(user), token };
     }
   
     async validateUser(userId: string) {
       return this.userService.findById(userId);
     }
   
     private generateToken(user: User) {
       const payload = { sub: user.id, email: user.email };
       return this.jwtService.sign(payload);
     }
   
     private sanitizeUser(user: User) {
       const { passwordHash, ...result } = user;
       return result;
     }
   }
   ```

2. **å‰ç«¯è®¤è¯æ¨¡å—**
   ```tsx
   // apps/frontend/src/contexts/AuthContext.tsx
   import { createContext, useContext, useState, useEffect } from 'react';
   import { authApi } from '@/lib/api';
   
   interface AuthContextType {
     user: User | null;
     token: string | null;
     login: (email: string, password: string) => Promise<void>;
     register: (data: RegisterData) => Promise<void>;
     logout: () => void;
     isLoading: boolean;
   }
   
   export const AuthContext = createContext<AuthContextType | null>(null);
   
   export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
     const [user, setUser] = useState<User | null>(null);
     const [token, setToken] = useState<string | null>(null);
     const [isLoading, setIsLoading] = useState(true);
   
     useEffect(() => {
       const storedToken = localStorage.getItem('token');
       if (storedToken) {
         setToken(storedToken);
         fetchUser(storedToken);
       } else {
         setIsLoading(false);
       }
     }, []);
   
     const fetchUser = async (authToken: string) => {
       try {
         const response = await authApi.getProfile(authToken);
         setUser(response.data);
       } catch {
         localStorage.removeItem('token');
         setToken(null);
       } finally {
         setIsLoading(false);
       }
     };
   
     const login = async (email: string, password: string) => {
       const response = await authApi.login({ email, password });
       const { user, token } = response.data;
       localStorage.setItem('token', token);
       setToken(token);
       setUser(user);
     };
   
     const register = async (data: RegisterData) => {
       const response = await authApi.register(data);
       const { user, token } = response.data;
       localStorage.setItem('token', token);
       setToken(token);
       setUser(user);
     };
   
     const logout = () => {
       localStorage.removeItem('token');
       setToken(null);
       setUser(null);
     };
   
     return (
       <AuthContext.Provider value={{ user, token, login, register, logout, isLoading }}>
         {children}
       </AuthContext.Provider>
     );
   };
   ```

3. **å¤šæ™ºèƒ½ä½“å¼€å‘é…ç½®**
   ```yaml
   # auth-development.yaml
   name: "auth-system-development"
   description: "ç”¨æˆ·è®¤è¯ç³»ç»Ÿå¼€å‘"
   parallel: true
   agents:
     - name: "backend-auth-dev"
       task: "å®ç°åç«¯ JWT è®¤è¯ç³»ç»Ÿ"
       workingDir: "apps/backend"
       output: "src/auth/"
     - name: "frontend-auth-dev"
       task: "å®ç°å‰ç«¯è®¤è¯ä¸Šä¸‹æ–‡å’Œç»„ä»¶"
       workingDir: "apps/frontend"
       output: "src/contexts/ src/components/auth/"
     - name: "security-reviewer"
       task: "å®‰å…¨å®¡è®¡å’Œæ¼æ´æ£€æŸ¥"
       context: "è®¤è¯ä»£ç "
   ```

**äº¤ä»˜ç‰©ï¼š**
- å®Œæ•´çš„è®¤è¯åç«¯ API
- å‰ç«¯è®¤è¯ç»„ä»¶
- JWT ä¸­é—´ä»¶å’Œç­–ç•¥
- å®‰å…¨æµ‹è¯•æŠ¥å‘Š

#### ä»»åŠ¡ 3.5: å¥èº«è¿½è¸ªåŠŸèƒ½ (3å¤©)

**ç›®æ ‡ï¼š** å®ç°å¥èº«è®°å½•å’Œåˆ†æåŠŸèƒ½

**å…·ä½“æ­¥éª¤ï¼š**

1. **å¥èº«è®°å½•åŠŸèƒ½**
   ```typescript
   // apps/backend/src/workouts/workouts.service.ts
   import { Injectable, NotFoundException } from '@nestjs/common';
   import { PrismaService } from '../prisma/prisma.service';
   import { CreateWorkoutDto } from './dto/create-workout.dto';
   
   @Injectable()
   export class WorkoutsService {
     constructor(private prisma: PrismaService) {}
   
     async create(userId: string, dto: CreateWorkoutDto) {
       const workout = await this.prisma.workout.create({
         data: {
           userId,
           type: dto.type,
           name: dto.name,
           duration: dto.duration,
           calories: dto.calories,
           distance: dto.distance,
           startTime: new Date(dto.startTime),
           endTime: new Date(dto.endTime),
           exercises: {
             create: dto.exercises.map(ex => ({
               name: ex.name,
               sets: ex.sets,
               reps: ex.reps,
               weight: ex.weight,
               duration: ex.duration,
             })),
           },
         },
         include: {
           exercises: true,
         },
       });
   
       await this.updateUserStats(userId);
       return workout;
     }
   
     async findAll(userId: string, query: WorkoutQueryDto) {
       const workouts = await this.prisma.workout.findMany({
         where: {
           userId,
           type: query.type,
           startTime: {
             gte: query.startDate,
             lte: query.endDate,
           },
         },
         include: {
           exercises: true,
         },
         orderBy: { startTime: 'desc' },
         skip: query.skip,
         take: query.take,
       });
   
       const total = await this.prisma.workout.count({
         where: {
           userId,
           type: query.type,
           startTime: {
             gte: query.startDate,
             lte: query.endDate,
           },
         },
       });
   
       return { workouts, total };
     }
   
     async getStats(userId: string, period: string) {
       const startDate = new Date();
       switch (period) {
         case 'week':
           startDate.setDate(startDate.getDate() - 7);
           break;
         case 'month':
           startDate.setMonth(startDate.getMonth() - 1);
           break;
         case 'year':
           startDate.setFullYear(startDate.getFullYear() - 1);
           break;
       }
   
       const workouts = await this.prisma.workout.findMany({
         where: {
           userId,
           startTime: { gte: startDate },
         },
         include: { exercises: true },
       });
   
       return {
         totalWorkouts: workouts.length,
         totalDuration: workouts.reduce((sum, w) => sum + w.duration, 0),
         totalCalories: workouts.reduce((sum, w) => sum + w.calories, 0),
         totalDistance: workouts.reduce((sum, w) => sum + (w.distance || 0), 0),
         workoutsByType: this.groupByType(workouts),
         weeklyProgress: this.getWeeklyProgress(workouts),
       };
     }
   
     private async updateUserStats(userId: string) {
       const achievements = await this.checkAchievements(userId);
       for (const achievement of achievements) {
         await this.prisma.userAchievement.upsert({
           where: {
             userId_achievementId: {
               userId,
               achievementId: achievement.id,
             },
           },
           create: {
             userId,
             achievementId: achievement.id,
             progress: achievement.progress,
           },
           update: {
             progress: achievement.progress,
             completedAt: achievement.completed ? new Date() : null,
           },
         });
       }
     }
   }
   ```

2. **å‰ç«¯å¥èº«è¿½è¸ªç•Œé¢**
   ```tsx
   // apps/frontend/src/pages/workouts/index.tsx
   import { useState } from 'react';
   import { Card, Button, Modal, Form, Select, InputNumber, DatePicker } from 'antd';
   import { PlusOutlined } from '@ant-design/icons';
   import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
   import { workoutApi } from '@/lib/api';
   import { WorkoutList } from '@/components/workouts/WorkoutList';
   import { WorkoutChart } from '@/components/workouts/WorkoutChart';
   
   export default function WorkoutsPage() {
     const [isModalOpen, setIsModalOpen] = useState(false);
     const [form] = Form.useForm();
     const queryClient = useQueryClient();
   
     const { data: workouts, isLoading } = useQuery({
       queryKey: ['workouts'],
       queryFn: () => workoutApi.getAll(),
     });
   
     const { data: stats } = useQuery({
       queryKey: ['workoutStats'],
       queryFn: () => workoutApi.getStats('month'),
     });
   
     const createMutation = useMutation({
       mutationFn: (data: WorkoutFormData) => workoutApi.create(data),
       onSuccess: () => {
         queryClient.invalidateQueries({ queryKey: ['workouts'] });
         queryClient.invalidateQueries({ queryKey: ['workoutStats'] });
         setIsModalOpen(false);
         form.resetFields();
       },
     });
   
     const onFinish = (values: any) => {
       createMutation.mutate({
         ...values,
         startTime: values.timeRange[0].toISOString(),
         endTime: values.timeRange[1].toISOString(),
         exercises: [],
       });
     };
   
     return (
       <div className="workouts-page">
         <div className="page-header">
           <h1>æˆ‘çš„å¥èº«</h1>
           <Button type="primary" icon={<PlusOutlined />} onClick={() => setIsModalOpen(true)}>
             è®°å½•å¥èº«
           </Button>
         </div>
   
         <div className="stats-section">
           <Card>
             <Statistic title="æœ¬æœˆå¥èº«æ¬¡æ•°" value={stats?.totalWorkouts || 0} />
           </Card>
           <Card>
             <Statistic title="æ€»æ—¶é•¿" value={stats?.totalDuration || 0} suffix="åˆ†é’Ÿ" />
           </Card>
           <Card>
             <Statistic title="æ¶ˆè€—å¡è·¯é‡Œ" value={stats?.totalCalories || 0} suffix="kcal" />
           </Card>
           <Card>
             <Statistic title="æ€»è·ç¦»" value={stats?.totalDistance || 0} suffix="km" />
           </Card>
         </div>
   
         <Card title="å¥èº«è¶‹åŠ¿" className="chart-card">
           <WorkoutChart data={stats?.weeklyProgress || []} />
         </Card>
   
         <Card title="å¥èº«è®°å½•" className="list-card">
           <WorkoutList workouts={workouts?.workouts || []} isLoading={isLoading} />
         </Card>
   
         <Modal
           title="è®°å½•å¥èº«"
           open={isModalOpen}
           onCancel={() => setIsModalOpen(false)}
           footer={null}
         >
           <Form form={form} layout="vertical" onFinish={onFinish}>
             <Form.Item name="type" label="å¥èº«ç±»å‹" rules={[{ required: true }]}>
               <Select
                 options={[
                   { value: 'running', label: 'è·‘æ­¥' },
                   { value: 'cycling', label: 'éª‘è¡Œ' },
                   { value: 'swimming', label: 'æ¸¸æ³³' },
                   { value: 'workout', label: 'åŠ›é‡è®­ç»ƒ' },
                   { value: 'yoga', label: 'ç‘œä¼½' },
                 ]}
               />
             </Form.Item>
             <Form.Item name="name" label="å¥èº«åç§°" rules={[{ required: true }]}>
               <Input />
             </Form.Item>
             <Form.Item name="duration" label="æ—¶é•¿ï¼ˆåˆ†é’Ÿï¼‰" rules={[{ required: true }]}>
               <InputNumber min={1} style={{ width: '100%' }} />
             </Form.Item>
             <Form.Item name="calories" label="æ¶ˆè€—å¡è·¯é‡Œ">
               <InputNumber min={0} style={{ width: '100%' }} />
             </Form.Item>
             <Form.Item name="timeRange" label="å¥èº«æ—¶é—´" rules={[{ required: true }]}>
               <DatePicker.RangePicker showTime />
             </Form.Item>
             <Form.Item>
               <Button type="primary" htmlType="submit" loading={createMutation.isLoading}>
                 ä¿å­˜
               </Button>
             </Form.Item>
           </Form>
         </Modal>
       </div>
     );
   }
   ```

**äº¤ä»˜ç‰©ï¼š**
- å®Œæ•´çš„å¥èº«è¿½è¸ªåç«¯ API
- å‰ç«¯å¥èº«è®°å½•å’Œç»Ÿè®¡ç•Œé¢
- æ•°æ®åˆ†æå’Œå¯è§†åŒ–ç»„ä»¶
- æˆå°±ç³»ç»Ÿé›†æˆ

#### ä»»åŠ¡ 3.6: ç¤¾äº¤åŠŸèƒ½ (3å¤©)

**ç›®æ ‡ï¼š** å®ç°ç¤¾åŒºäº’åŠ¨å’Œç¤¾äº¤åŠŸèƒ½

**å…·ä½“æ­¥éª¤ï¼š**

1. **ç¤¾äº¤åŠŸèƒ½åç«¯**
   ```typescript
   // apps/backend/src/social/social.service.ts
   import { Injectable, ForbiddenException } from '@nestjs/common';
   import { PrismaService } from '../prisma/prisma.service';
   
   @Injectable()
   export class SocialService {
     constructor(private prisma: PrismaService) {}
   
     async createPost(userId: string, content: string, mediaUrls: string[], workoutId?: string) {
       return this.prisma.post.create({
         data: {
           userId,
           content,
           mediaUrls,
           workoutId,
         },
         include: {
           user: {
             select: { id: true, username: true, avatar: true },
           },
           workout: true,
           _count: {
             select: { comments: true, likes: true },
           },
         },
       });
     }
   
     async getFeed(userId: string, page = 1, limit = 20) {
       const following = await this.prisma.follow.findMany({
         where: { followerId: userId },
         select: { followingId: true },
       });
   
       const userIds = [userId, ...following.map(f => f.followingId)];
   
       const posts = await this.prisma.post.findMany({
         where: { userId: { in: userIds } },
         include: {
           user: {
             select: { id: true, username: true, avatar: true },
           },
           workout: true,
           comments: {
             include: {
               user: {
                 select: { id: true, username: true, avatar: true },
               },
             },
             orderBy: { createdAt: 'desc' },
             take: 3,
           },
           likes: {
             where: { userId },
             select: { userId: true },
           },
           _count: {
             select: { comments: true, likes: true },
           },
         },
         orderBy: { createdAt: 'desc' },
         skip: (page - 1) * limit,
         take: limit,
       });
   
       return posts.map(post => ({
         ...post,
         isLiked: post.likes.length > 0,
         likes: undefined,
       }));
     }
   
     async likePost(userId: string, postId: string) {
       const existing = await this.prisma.like.findUnique({
         where: {
           userId_postId: { userId, postId },
         },
       });
   
       if (existing) {
         await this.prisma.like.delete({
           where: { id: existing.id },
         });
         return { liked: false };
       }
   
       await this.prisma.like.create({
         data: { userId, postId },
       });
       return { liked: true };
     }
   
     async followUser(followerId: string, followingId: string) {
       if (followerId === followingId) {
         throw new ForbiddenException('ä¸èƒ½å…³æ³¨è‡ªå·±');
       }
   
       const existing = await this.prisma.follow.findUnique({
         where: {
           followerId_followingId: { followerId, followingId },
         },
       });
   
       if (existing) {
         await this.prisma.follow.delete({
           where: { id: existing.id },
         });
         return { followed: false };
       }
   
       await this.prisma.follow.create({
         data: { followerId, followingId },
       });
       return { followed: true };
     }
   }
   ```

2. **å‰ç«¯ç¤¾åŒºç•Œé¢**
   ```tsx
   // apps/frontend/src/pages/feed/index.tsx
   import { useState } from 'react';
   import { Card, Avatar, Button, Input, Image, Dropdown } from 'antd';
   import { HeartOutlined, HeartFilled, CommentOutlined, ShareAltOutlined } from '@ant-design/icons';
   import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
   import { socialApi } from '@/lib/api';
   import { useAuth } from '@/contexts/AuthContext';
   
   interface PostCardProps {
     post: Post;
   }
   
   export const PostCard: React.FC<PostCardProps> = ({ post }) => {
     const { user } = useAuth();
     const queryClient = useQueryClient();
   
     const likeMutation = useMutation({
       mutationFn: () => socialApi.likePost(post.id),
       onSuccess: () => {
         queryClient.invalidateQueries({ queryKey: ['feed'] });
       },
     });
   
     const followMutation = useMutation({
       mutationFn: () => socialApi.followUser(post.user.id),
       onSuccess: () => {
         queryClient.invalidateQueries({ queryKey: ['feed'] });
       },
     });
   
     return (
       <Card className="post-card">
         <div className="post-header">
           <Avatar src={post.user.avatar} size={48} />
           <div className="post-info">
             <span className="username">{post.user.username}</span>
             <span className="time">{formatTime(post.createdAt)}</span>
           </div>
           {user?.id !== post.user.id && (
             <Button
               size="small"
               onClick={() => followMutation.mutate()}
             >
               {post.isFollowing ? 'å–æ¶ˆå…³æ³¨' : 'å…³æ³¨'}
             </Button>
           )}
         </div>
   
         <div className="post-content">
           <p>{post.content}</p>
         </div>
   
         {post.mediaUrls.length > 0 && (
           <div className="post-media">
             <Image.PreviewGroup>
               {post.mediaUrls.map((url, index) => (
                 <Image key={index} src={url} />
               ))}
             </Image.PreviewGroup>
           </div>
         )}
   
         {post.workout && (
           <Card size="small" className="workout-card">
             <span>ğŸƒ {post.workout.name} - {post.workout.duration}åˆ†é’Ÿ</span>
           </Card>
         )}
   
         <div className="post-actions">
           <Button
             type="text"
             icon={post.isLiked ? <HeartFilled style={{ color: '#ff4d4f' }} /> : <HeartOutlined />}
             onClick={() => likeMutation.mutate()}
           >
             {post._count.likes}
           </Button>
           <Button type="text" icon={<CommentOutlined />}>
             {post._count.comments}
           </Button>
           <Button type="text" icon={<ShareAltOutlined />} />
         </div>
       </Card>
     );
   };
   
   export default function FeedPage() {
     const [newPost, setNewPost] = useState('');
     const queryClient = useQueryClient();
   
     const { data: posts, isLoading } = useQuery({
       queryKey: ['feed'],
       queryFn: () => socialApi.getFeed(),
     });
   
     const createPostMutation = useMutation({
       mutationFn: (content: string) => socialApi.createPost(content),
       onSuccess: () => {
         queryClient.invalidateQueries({ queryKey: ['feed'] });
         setNewPost('');
       },
     });
   
     return (
       <div className="feed-page">
         <Card className="new-post-card">
           <Input.TextArea
             value={newPost}
             onChange={(e) => setNewPost(e.target.value)}
             placeholder="åˆ†äº«ä½ çš„å¥èº«åŠ¨æ€..."
             autoSize={{ minRows: 2, maxRows: 4 }}
           />
           <div className="post-actions">
             <Button
               type="primary"
               disabled={!newPost.trim()}
               onClick={() => createPostMutation.mutate(newPost)}
               loading={createPostMutation.isLoading}
             >
               å‘å¸ƒ
             </Button>
           </div>
         </Card>
   
         <div className="posts-list">
           {posts?.map((post: Post) => (
             <PostCard key={post.id} post={post} />
           ))}
         </div>
       </div>
     );
   }
   ```

**äº¤ä»˜ç‰©ï¼š**
- å®Œæ•´çš„ç¤¾äº¤åç«¯ API
- å‰ç«¯åŠ¨æ€æµå’Œå¸–å­ç»„ä»¶
- ç‚¹èµã€è¯„è®ºã€å…³æ³¨åŠŸèƒ½
- å®æ—¶æ›´æ–°æ”¯æŒ

### ç¬¬10å‘¨ï¼šAI åŠŸèƒ½å’Œéƒ¨ç½²

#### ä»»åŠ¡ 3.7: AI æ™ºèƒ½æ¨è (2å¤©)

**ç›®æ ‡ï¼š** å®ç°ä¸ªæ€§åŒ–å¥èº«æ¨èåŠŸèƒ½

**å…·ä½“æ­¥éª¤ï¼š**

1. **AI æ¨èæœåŠ¡**
   ```typescript
   // apps/backend/src/ai/ai.service.ts
   import { Injectable } from '@nestjs/common';
   import { OpenAIService } from './openai.service';
   import { PrismaService } from '../prisma/prisma.service';
   
   @Injectable()
   export class AIService {
     constructor(
       private openai: OpenAIService,
       private prisma: PrismaService,
     ) {}
   
     async generateWorkoutPlan(userId: string, preferences: WorkoutPreferences) {
       const user = await this.prisma.user.findUnique({
         where: { id: userId },
         include: {
           workouts: {
             orderBy: { startTime: 'desc' },
             take: 30,
           },
           achievements: {
             include: { achievement: true },
           },
         },
       });
   
       const prompt = this.buildWorkoutPrompt(user, preferences);
       const response = await this.openai.complete(prompt);
   
       return this.parseWorkoutPlan(response);
     }
   
     async getSmartSuggestion(userId: string) {
       const recentWorkouts = await this.prisma.workout.findMany({
         where: { userId },
         orderBy: { startTime: 'desc' },
         take: 7,
       });
   
       const achievements = await this.prisma.userAchievement.findMany({
         where: { userId, completedAt: null },
         include: { achievement: true },
       });
   
       const prompt = `åŸºäºç”¨æˆ·æœ€è¿‘7å¤©çš„å¥èº«æ•°æ®å’Œå¾…å®Œæˆçš„æˆå°±ï¼Œç”Ÿæˆä¸€æ¡é¼“åŠ±å’Œå»ºè®®ï¼š
       æœ€è¿‘å¥èº«æ¬¡æ•°ï¼š${recentWorkouts.length}
       å¾…å®Œæˆæˆå°±ï¼š${achievements.map(a => a.achievement.name).join(', ')}
       æœ€è¿‘ä¸€æ¬¡å¥èº«ç±»å‹ï¼š${recentWorkouts[0]?.type || 'æ— '}
       
       è¯·ç”¨ç®€æ´é¼“åŠ±çš„è¯­æ°”ç”Ÿæˆå»ºè®®ï¼ˆä¸è¶…è¿‡50å­—ï¼‰ï¼š`;
   
       const suggestion = await this.openai.complete(prompt);
       return suggestion.trim();
     }
   
     async analyzeWorkoutForm(userId: string, workoutData: any) {
       const prompt = `åˆ†æä»¥ä¸‹å¥èº«æ•°æ®ï¼Œç»™å‡ºæ”¹è¿›å»ºè®®ï¼š
       å¥èº«ç±»å‹ï¼š${workoutData.type}
       æŒç»­æ—¶é—´ï¼š${workoutData.duration}åˆ†é’Ÿ
       æ¶ˆè€—å¡è·¯é‡Œï¼š${workoutData.calories}
       è®­ç»ƒé¢‘ç‡ï¼š${workoutData.frequency}
       
       è¯·ä»ä»¥ä¸‹æ–¹é¢åˆ†æï¼š
       1. è®­ç»ƒå¼ºåº¦è¯„ä¼°
       2. æ”¹è¿›å»ºè®®
       3. ä¸‹ä¸€æ­¥è®­ç»ƒç›®æ ‡å»ºè®®`;
   
       return this.openai.complete(prompt);
     }
   
     private buildWorkoutPrompt(user: any, preferences: WorkoutPreferences) {
       // æ„å»ºè¯¦ç»†çš„å¥èº«è®¡åˆ’ç”Ÿæˆæç¤ºè¯
     }
   
     private parseWorkoutPlan(response: string) {
       // è§£æ AI è¿”å›çš„è®­ç»ƒè®¡åˆ’
     }
   }
   ```

**äº¤ä»˜ç‰©ï¼š**
- AI æ¨èæœåŠ¡
- å¥èº«è®¡åˆ’ç”ŸæˆåŠŸèƒ½
- æ™ºèƒ½å»ºè®®åŠŸèƒ½
- è¡¨å•åˆ†æåŠŸèƒ½

#### ä»»åŠ¡ 3.8: åº”ç”¨éƒ¨ç½² (3å¤©)

**ç›®æ ‡ï¼š** å®Œæˆå…¨æ ˆåº”ç”¨çš„éƒ¨ç½²å’Œè¿ç»´é…ç½®

**å…·ä½“æ­¥éª¤ï¼š**

1. **å‰ç«¯éƒ¨ç½²ï¼ˆVercelï¼‰**
   ```typescript
   // apps/frontend/vercel.json
   {
     "buildCommand": "pnpm build",
     "outputDirectory": ".next",
     "framework": "nextjs",
     "rewrites": [
       {
         "source": "/api/:path*",
         "destination": "https://api.fitpro.social/:path*"
       }
     ],
     "headers": [
       {
         "source": "/(.*)",
         "headers": [
           {
             "key": "X-Frame-Options",
             "value": "DENY"
           },
           {
             "key": "X-Content-Type-Options",
             "value": "nosniff"
           }
         ]
       }
     ]
   }
   
   // .env.production
   NEXT_PUBLIC_API_URL=https://api.fitpro.social
   NEXT_PUBLIC_APP_URL=https://fitpro.social
   ```

2. **åç«¯éƒ¨ç½²ï¼ˆRailway/é˜¿é‡Œäº‘ï¼‰**
   ```yaml
   # apps/backend/Dockerfile
   FROM node:20-alpine
   
   WORKDIR /app
   
   COPY package*.json ./
   RUN npm ci --only=production
   
   COPY prisma ./prisma/
   RUN npx prisma generate
   
   COPY . .
   
   RUN npm run build
   
   EXPOSE 3001
   
   CMD ["npm", "start"]
   ```

3. **CI/CD é…ç½®**
   ```yaml
   # .github/workflows/deploy.yml
   name: Deploy
   
   on:
     push:
       branches: [main]
   
   jobs:
     deploy-frontend:
       runs-on: ubuntu-latest
       steps:
         - uses: actions/checkout@v4
         - uses: pnpm/action-setup@v2
         - uses: actions/setup-node@v4
           with:
             node-version: '20'
             cache: 'pnpm'
         - run: pnpm install --frozen-lockfile
         - run: pnpm build
           env:
             NEXT_PUBLIC_API_URL: ${{ secrets.API_URL }}
         - uses: amondnet/vercel-action@v25
           with:
             vercel-token: ${{ secrets.VERCEL_TOKEN }}
             vercel-org-id: ${{ secrets.ORG_ID }}
             vercel-project-id: ${{ secrets.PROJECT_ID }}
             vercel-args: '--prod'
   
     deploy-backend:
       runs-on: ubuntu-latest
       steps:
         - uses: actions/checkout@v4
         - uses: pnpm/action-setup@v2
         - uses: actions/setup-node@v4
           with:
             node-version: '20'
             cache: 'pnpm'
         - run: pnpm install --frozen-lockfile
         - run: pnpm build
           env:
             DATABASE_URL: ${{ secrets.DATABASE_URL }}
             JWT_SECRET: ${{ secrets.JWT_SECRET }}
         - uses: docker/build-push-action@v5
           with:
             context: ./apps/backend
             push: true
             tags: ghcr.io/ygh/fitpro-social-backend:${{ github.sha }}
   ```

4. **ç›‘æ§å’Œæ—¥å¿—**
   ```typescript
   // apps/backend/src/main.ts
   import { NestFactory } from '@nestjs/core';
   import { AppModule } from './app.module';
   import { WinstonModule } from 'nest-winston';
   import { winstonConfig } from './config/winston.config';
   
   async function bootstrap() {
     const app = await NestFactory.create(AppModule, {
       logger: WinstonModule.createLogger(winstonConfig),
     });
     
     // å¯ç”¨ CORS
     app.enableCors({
       origin: process.env.FRONTEND_URL,
       credentials: true,
     });
     
     await app.listen(process.env.PORT || 3001);
   }
   bootstrap();
   ```

**äº¤ä»˜ç‰©ï¼š**
- å‰ç«¯ Vercel éƒ¨ç½²é…ç½®
- åç«¯ Docker éƒ¨ç½²é…ç½®
- CI/CD è‡ªåŠ¨åŒ–æµç¨‹
- ç›‘æ§å’Œæ—¥å¿—é…ç½®
- æ€§èƒ½æµ‹è¯•æŠ¥å‘Š

## ğŸ¯ äº¤ä»˜ç‰©æ¸…å•

### æ–‡æ¡£äº¤ä»˜ç‰©
- [ ] ç³»ç»Ÿæ¶æ„æ–‡æ¡£
- [ ] API æ¥å£æ–‡æ¡£ï¼ˆSwagger/OpenAPIï¼‰
- [ ] éƒ¨ç½²è¿ç»´æ‰‹å†Œ
- [ ] ç”¨æˆ·ä½¿ç”¨æŒ‡å—
- [ ] æ•°æ®åº“æ–‡æ¡£
- [ ] æµ‹è¯•æŠ¥å‘Š

### ä»£ç äº¤ä»˜ç‰©
- [ ] å®Œæ•´çš„å‰ç«¯é¡¹ç›®ï¼ˆNext.jsï¼‰
- [ ] å®Œæ•´çš„åç«¯é¡¹ç›®ï¼ˆNestJSï¼‰
- [ ] æ•°æ®åº“ Schema å’Œè¿ç§»
- [ ] CI/CD é…ç½®æ–‡ä»¶
- [ ] ç›‘æ§å’Œæ—¥å¿—é…ç½®

### åŠŸèƒ½äº¤ä»˜ç‰©
- [ ] ç”¨æˆ·è®¤è¯ç³»ç»Ÿ
- [ ] å¥èº«è¿½è¸ªåŠŸèƒ½
- [ ] ç¤¾äº¤äº’åŠ¨åŠŸèƒ½
- [ ] AI æ™ºèƒ½æ¨è
- [ ] æ•°æ®åˆ†æå±•ç¤º

---

**é˜¶æ®µçŠ¶æ€ï¼š** ğŸŸ¡ å‡†å¤‡å¼€å§‹  
**é¢„è®¡å¼€å§‹æ—¶é—´ï¼š** 2026å¹´2æœˆ20æ—¥  
**é¢„è®¡å®Œæˆæ—¶é—´ï¼š** 2026å¹´3æœˆ19æ—¥  

> ğŸ’¡ æç¤ºï¼šæœ¬é˜¶æ®µæ˜¯æ•´ä¸ªå­¦ä¹ è®¡åˆ’çš„æ ¸å¿ƒï¼Œéœ€è¦æŠ•å…¥æ›´å¤šæ—¶é—´å’Œç²¾åŠ›ã€‚å»ºè®®ä½¿ç”¨ Oh-My-OpenCode çš„å¤šæ™ºèƒ½ä½“åŠŸèƒ½æ¥åŠ é€Ÿå¼€å‘ã€‚